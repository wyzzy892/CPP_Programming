Шаблоны функций.

Позволяют опредить универсальные конструкции, которые не зависят от типа. Т.е. на 
момент написания кода ничего неизвестно о типах. 

template<typename T>
T max(T a, T b){
	return a > b? a : b;
}

Можно использовать class вместо typename.

Для каждого типа шаблон компилируется отдельно.

Процесс замены параметра шаблона конкретным типом - инстанцирование.
Для каждого типа получается конкретный экземпляр шаблона.

Шаблон должен поддерживать операции для типов, которые будут в него инстанцированы.

Проверка выполняется в 2 этапа. 1 - без инстанцирования, 2 - с инстанцированием.

Если тип аргумента имеет вид, например double const&, int const&, то 
аргумент будет иметь тип double, int соответственно (ключевое слово const игнорируется, т.к. только
указывает на константность аргумента.)

Современный стандарт C++ позволяет самостоятельно определять тип при помощи инструкции auto.