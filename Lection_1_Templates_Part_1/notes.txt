Шаблоны функций.

Позволяют опредить универсальные конструкции, которые не зависят от типа. Т.е. на 
момент написания кода ничего неизвестно о типах. 

template<typename T>
T max(T a, T b){
	return a > b? a : b;
}

Можно использовать class вместо typename.

Для каждого типа шаблон компилируется отдельно.

Процесс замены параметра шаблона конкретным типом - инстанцирование.
Для каждого типа получается конкретный экземпляр шаблона.

Шаблон должен поддерживать операции для типов, которые будут в него инстанцированы.

Тип аргумента шаблона определяется путем исследования типов фактических аргументов функции. Этот процесс 
называется выведением аргументов шаблона. При выведении аргументов шаблона не принимается во внимание тип
значения, которое возвращается конкретизированным шаблоном. Т.е. если значение, возвращаемое конкретизированным 
шаблоном присваивается какой-либо переменной, то её тип не принимается во внимание, при формировании возвращаемого 
значения.

Имеется ввиду ошибка времени исполнения? Или ошибка компиляции? (не опечатка ли)
Пример ошибки компиляции - передача аргументами в шаблонную функцию параметров имеющих разные типы, 
но при этом функция принимает аргументы одного типа. Или объявление параметров шаблона через запятую: T a,b.


Если тип аргумента имеет вид, например double const&, int const&, то 
аргумент будет иметь тип double, int соответственно (ключевое слово const игнорируется, т.к. только
указывает на константность аргумента.)

Современный стандарт C++ позволяет самостоятельно определять тип на основании выражений в теле функции
при помощи инструкции auto. 
Со стандарта 11 можно использовать конструкцию decltype(...выражение...) для вывода типа.
Также можно явно указать возвращаемый тип, аналогичный типу аргументов.